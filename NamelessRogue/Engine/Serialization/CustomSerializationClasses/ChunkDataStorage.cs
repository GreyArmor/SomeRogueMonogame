using FlatSharp.Attributes;
using NamelessRogue.Engine.Components.ChunksAndTiles;
using NamelessRogue.Engine.Serialization.SerializationIfrastructure;
using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using NamelessRogue.Engine.Serialization.AutogeneratedSerializationClasses;
using Veldrid;

namespace NamelessRogue.Engine.Serialization.CustomSerializationClasses
{
	[FlatBufferTable]
	public class ChunkDataStorage : IStorage<ChunkData>
	{

		[FlatBufferItem(0)] public int ChunkResolution { get; set; }

		[FlatBufferItem(1)] public IList<ChunkStorage> Chunks { get; set; }
		[FlatBufferItem(2)] public IList<ChunkStorage> RealityBubbleChunks { get; set; }
		[FlatBufferItem(3)] public WorldSettingsStorage WorldSettings { get; set; }

		//[FlatBufferItem(4)] public TimelineLayerStorage Worldboard { get; set;}

		public void FillFrom(ChunkData component)
		{
			this.ChunkResolution = component.ChunkResolution;
			this.Chunks = component.GetChunks().Select(x=>x.Value).Select(chunk=> 
			{ 
				var storage = new ChunkStorage(); 
				storage.FillFrom(chunk); 
				return storage; 
			}).ToList();

			this.RealityBubbleChunks = component.GetRealityBubbleChunks().Select(x => x.Value).Select(chunk =>
			{
				var storage = new ChunkStorage();
				storage.FillFrom(chunk);
				return storage;
			}).ToList();

		//	Worldboard = new TimelineLayerStorage();
		//	Worldboard.FillFrom(component.WorldBoard);
		}

		public void FillTo(ChunkData component)
		{
			component.ChunkResolution = ChunkResolution;
			component.Chunks = new Dictionary<Point, Chunk>();
			foreach (var chunkStorage in Chunks)
			{
				var chunk = new Chunk();
				chunkStorage.FillTo(chunk);
				component.Chunks.Add(chunkStorage.ChunkWorldMapLocationPoint, chunk);
			}
			component.RealityBubbleChunks = new Dictionary<Point, Chunk>();
			foreach (var chunkStorage in RealityBubbleChunks)
			{
				var ch = component.Chunks[chunkStorage.ChunkWorldMapLocationPoint];
				component.RealityBubbleChunks.Add(chunkStorage.ChunkWorldMapLocationPoint, ch);
				if (ch.GetChunkTiles() != null)
				{
					ch.Loaded = true;
					ch.IsActive = true;
				}
			}
		}

		public static implicit operator ChunkData(ChunkDataStorage thisType)
		{
			ChunkData result = new ChunkData();
			thisType.FillTo(result);
			return result;
		}

		public static implicit operator ChunkDataStorage(ChunkData component)
		{
			ChunkDataStorage result = new ChunkDataStorage();
			 result.FillFrom(component);
			return result;
		}

	}
}
