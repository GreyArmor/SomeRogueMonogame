
// AUTOGENERATED
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using FlatSharp.Attributes;
using NamelessRogue.Engine.Serialization.SerializationIfrastructure;
using NamelessRogue.Engine.Serialization.AutogeneratedSerializationClasses;
using NamelessRogue.Engine.Generation.World;
using NamelessRogue.Engine.Generation.Noise;

namespace NamelessRogue.Engine.Serialization.CustomSerializationClasses
{
	[FlatBufferTable]
	public class TimelineLayerStorage : IStorage<Generation.World.WorldBoard>
	{
		[FlatBufferItem(0)] public string Id { get; set; }
		[FlatBufferItem(1)] public string ParentEntityId { get; set; }
		[FlatBufferItem(2)] public int Age { get; set; }

		[FlatBufferItem(3)] public IList<WorldTileStorage> WorldTiles { get; set; }

		[FlatBufferItem(4)] public IList<CivilizationStorage> Civilizations { get; set; }

		[FlatBufferItem(5)] public IList<RegionStorage> Continents { get; set; }

		[FlatBufferItem(6)] public IList<RegionStorage> Islands { get; set; }

		[FlatBufferItem(7)] public IList<RegionStorage> Mountains { get; set; }

		[FlatBufferItem(8)] public IList<RegionStorage> Forests { get; set; }

		[FlatBufferItem(9)] public IList<RegionStorage> Deserts { get; set; }

		[FlatBufferItem(10)] public IList<RegionStorage> Swamps { get; set; }

		[FlatBufferItem(11)] public ChunkDataStorage Chunks { get; set; }

		[FlatBufferItem(12)] public IList<byte> ElevationMap { get; set; }

		[FlatBufferItem(13)] public IList<bool> RiverMap { get; set; }

		[FlatBufferItem(14)] public IList<bool> RiverBorderMap { get; set; }

		[FlatBufferItem(15)] public IList<WaterBorderLineStorage> BorderLines { get; set; }

		//for 2d arrays
		[FlatBufferItem(16)] public int WorldMapResolution { get; set; }

		[FlatBufferItem(17)] public IList<TileForInlandWaterConnectivityStorage> InlandWaterConnectivity { get; set; }

		public void FillFrom(Generation.World.WorldBoard component)
		{

			Age = 0;

			WorldMapResolution = component.WorldTiles.GetLength(0);

			WorldTiles = new WorldTileStorage[WorldMapResolution * WorldMapResolution];

			WorldMapResolution = component.WorldTiles.GetLength(0);

			for (int i = 0; i < WorldMapResolution; i++)
			{
				for (int j = 0; j < WorldMapResolution; j++)
				{
					WorldTiles[i* WorldMapResolution + j] = component.WorldTiles[i, j];
				}
			}

			Chunks = component.Chunks;



			ElevationMap = new byte[WorldMapResolution * WorldMapResolution];
			for (int i = 0; i < WorldMapResolution; i++)
			{
				for (int j = 0; j < WorldMapResolution; j++)
				{
					ElevationMap[i * WorldMapResolution + j] = (byte)(component.ElevationMap[i][j]*255);
				}
			}

			RiverMap = new bool[WorldMapResolution * WorldMapResolution];
			for (int i = 0; i < WorldMapResolution; i++)
			{
				for (int j = 0; j < WorldMapResolution; j++)
				{
					RiverMap[i * WorldMapResolution + j] = component.RiverMap[i][j];
				}
			}


			RiverBorderMap = new bool[WorldMapResolution * WorldMapResolution];
			for (int i = 0; i < WorldMapResolution; i++)
			{
				for (int j = 0; j < WorldMapResolution; j++)
				{
					RiverBorderMap[i * WorldMapResolution + j] = component.RiverBorderMap[i][j];
				}
			}

			InlandWaterConnectivity = new TileForInlandWaterConnectivityStorage[WorldMapResolution * WorldMapResolution];
			for (int i = 0; i < WorldMapResolution; i++)
			{
				for (int j = 0; j < WorldMapResolution; j++)
				{
					InlandWaterConnectivity[i * WorldMapResolution + j] = component.TerrainFeatures[i][j];
				}
			}
			BorderLines = new List<WaterBorderLineStorage>();
			foreach (var borderLine in component.RiverBorderLines)
			{
				BorderLines.Add(borderLine);
			}

		}

		public void FillTo(Generation.World.WorldBoard component)
		{
		//	component.Age = Age;

			component.WorldTiles = new Generation.World.WorldTile[WorldMapResolution, WorldMapResolution];

			for (int i = 0; i < WorldMapResolution; i++)
			{
				for (int j = 0; j < WorldMapResolution; j++)
				{
					component.WorldTiles[i, j] = WorldTiles[i*WorldMapResolution + j];
				}
			}

			component.Chunks = Chunks;

			component.ElevationMap = new float[WorldMapResolution][];
			for (int i = 0; i < WorldMapResolution; i++)
			{
				component.ElevationMap[i] = new float[WorldMapResolution];
				for (int j = 0; j < WorldMapResolution; j++)
				{
					component.ElevationMap[i][j] = ElevationMap[i * WorldMapResolution + j]/255f;
				}
			}

			component.RiverMap = new bool[WorldMapResolution][];
			for (int i = 0; i < WorldMapResolution; i++)
			{
				component.RiverMap[i] = new bool[WorldMapResolution];
				for (int j = 0; j < WorldMapResolution; j++)
				{
					component.RiverMap[i][j] = RiverMap[i * WorldMapResolution + j];
				}
			}


			component.RiverBorderMap = new bool[WorldMapResolution][];
			for (int i = 0; i < WorldMapResolution; i++)
			{
				component.RiverBorderMap[i] = new bool[WorldMapResolution];
				for (int j = 0; j < WorldMapResolution; j++)
				{
					component.RiverBorderMap[i][j] = RiverBorderMap[i * WorldMapResolution + j];
				}
			}

			component.TerrainFeatures = new TileForPainting[WorldMapResolution][];
			for (int i = 0; i < WorldMapResolution; i++)
			{
				component.TerrainFeatures[i] = new TileForPainting[WorldMapResolution];
				for (int j = 0; j < WorldMapResolution; j++)
				{
					component.TerrainFeatures[i][j] = InlandWaterConnectivity[i * WorldMapResolution + j];
				}
			}



			component.RiverBorderLines = new List<Generation.World.Waypoints>();
			foreach (var borderLineStorage in BorderLines)
			{
				component.RiverBorderLines.Add(borderLineStorage);
			}
		}

		public static implicit operator Generation.World.WorldBoard(TimelineLayerStorage thisType)
		{
			if (thisType == null) { return null; }
			Generation.World.WorldBoard result = new Generation.World.WorldBoard();
			thisType.FillTo(result);
			return result;
		}

		public static implicit operator TimelineLayerStorage(Generation.World.WorldBoard component)
		{
			if (component == null) { return null; }
			TimelineLayerStorage result = new TimelineLayerStorage();
			result.FillFrom(component);
			return result;
		}

	}

}