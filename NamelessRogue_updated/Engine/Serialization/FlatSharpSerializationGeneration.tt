<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="NamelessRogue_updated.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="NamelessRogue.Engine.Components" #>
<#@ import namespace="NamelessRogue.Engine.Serialization" #>

<# 
    string ToGenericTypeString(Type t)
    {
        if (!t.IsGenericType)
            return t.Name;
        string genericTypeName = t.GetGenericTypeDefinition().Name;
        genericTypeName = genericTypeName.Substring(0,
            genericTypeName.IndexOf('`'));
        string genericArgs = string.Join(",",
            t.GetGenericArguments()
                .Select(ta => ToGenericTypeString(ta)).ToArray());
        return genericTypeName + "<" + genericArgs + ">";
    }

        void FindTypes(Type o, List<Type> nestedTypes, bool firstTime = true)
            {
                if (o != null)
                {
                    Type t = o;
                    if (!firstTime)
                    {
                        firstTime = false;
                        nestedTypes.Add(t);
                    }
                    foreach (PropertyInfo pi in t.GetProperties())
                    {
                        if (
                              !pi.PropertyType.IsValueType &&
                              !pi.PropertyType.IsEnum &&
                              !nestedTypes.Any(x => x.FullName == pi.PropertyType.FullName) &&
                              !pi.PropertyType.IsGenericType &&
                              !pi.PropertyType.IsArray
                           )
                        {
                            FindTypes(pi.PropertyType, nestedTypes, false);
                        }
                    }
                }
            }
            
    var icomponent = typeof(IComponent);

    //get all component types
	var types = AppDomain.CurrentDomain.GetAssemblies()
				.SelectMany(s => s.GetTypes())
				.Where(p => icomponent.IsAssignableFrom(p) && p != icomponent && !p.IsAbstract).ToList();

    //then get all types referenced in component types
    var nestedTypes = types.ToList();

    foreach(var type in types)
	{
        FindTypes(type, nestedTypes);
    }

    types = nestedTypes.Distinct().ToList();

    //and now we need types from game assembly

    types = types.Where(t => t.Assembly.ManifestModule.Name == "NamelessRogue_updated.dll").ToList();

    var baseComponentProperties = typeof(Component).GetProperties();
    var listOfEnums = new List<string>();
#>

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using FlatSharp.Attributes;

namespace NamelessRogue.Engine.Serialization.SerializationClasses
{
<#
foreach (var type in types)
{

 if(type.GetCustomAttributes(true).Any(a=>a.GetType() == typeof(NamelessRogue_updated.Engine.Serialization.SkipClassGeneration)))
 {
     continue;
 }


int flatBufferAttributeCounter = 0; 
#>
    [FlatBufferTable]
    public class <#= type.Name #>
    {
<#
    foreach (var property in baseComponentProperties)
    {
   
        var fullName = ToGenericTypeString(property.PropertyType);
        if(property.PropertyType.IsEnum)
	    {
           listOfEnums.Add(fullName);
	    }
#>
        [FlatBufferItem(<#= flatBufferAttributeCounter#>)]  public <#= fullName #> <#= property.Name #> { get; set; }
<#
        flatBufferAttributeCounter++;
    }

    foreach (var property in type.GetProperties().Where(p=>baseComponentProperties.Any(bp=>bp.Name==p.Name)==false))
    {
        var fullName = ToGenericTypeString(property.PropertyType);
        if(property.PropertyType.IsEnum)
	    {
           listOfEnums.Add(fullName);
	    }
#>
        [FlatBufferItem(<#= flatBufferAttributeCounter#>)]  public <#= fullName #> <#= property.Name #> { get; set; }
<#
        flatBufferAttributeCounter++;
    }
#>

        public void FillFrom(<#= type.FullName #> component)
        {
<#
      foreach (var property in type.GetProperties())
      {


          if(property.PropertyType.IsEnum)
		  {
#>
            this.<#= property.Name #> = (<#= property.PropertyType.Name #>)component.<#= property.Name #>;
<#
		  }
          else
		  {
#>
            this.<#= property.Name #> = component.<#= property.Name #>;
<#
		  }
	  }
#>
        }

        public void FillTo(<#= type.FullName #> component)
        {
<#
      foreach (var property in type.GetProperties())
      {
          if(property.PropertyType.IsEnum)
		  {
#>
            component.<#= property.Name #> = (<#= property.PropertyType.FullName #>)this.<#= property.Name #>;
<#
		  }
          else
		  {
#>
            component.<#= property.Name #> = this.<#= property.Name #>;
<#
		  }
	  }
#>

        }

        public static implicit operator <#= type.FullName #> (<#= type.Name #> thisType)
        {
            <#= type.FullName #> result = new <#= type.FullName #>();
            thisType.FillTo(result);
            return result;
        }

        public static implicit operator <#= type.Name #> ( <#= type.FullName #>  component)
        {
            <#= type.Name #> result = new <#= type.Name #>();
            result.FillFrom(result);
            return result;
        }

    }
<#
} 
#>


<#

  listOfEnums = listOfEnums.GroupBy(t=>t).Select(g => g.First()).ToList();


   var enumTypes = AppDomain.CurrentDomain.GetAssemblies()
				.SelectMany(s => s.GetTypes()).Where(t=>t.IsEnum && listOfEnums.Contains(t.Name)).ToList();

    enumTypes = enumTypes.Distinct().ToList();


foreach(Type enumType in enumTypes)
{
       var underType = enumType.GetEnumUnderlyingType();
       var enumValues = enumType.GetEnumNames();
#>

    [FlatBufferEnum(typeof(<#= underType.Name #>))]
    public enum <#= enumType.Name #> : <#= underType.Name #> 
    {
    <#
            foreach(var enumName in enumValues)
            {
    #>
            <#= enumName #>,
    <#
            }
    #>
    }


<#   
}
#>

}